"""
Enhanced Vulnerability Management System
Real-time vulnerability scanning with automated patching
"""

import logging
import asyncio
import json
import re
from typing import Dict, List, Optional, Any, Set
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from uuid import uuid4
import hashlib

logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class VulnerabilityStatus(Enum):
    OPEN = "open"
    CONFIRMED = "confirmed"
    PATCHING = "patching"
    PATCHED = "patched"
    MITIGATED = "mitigated"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"

class PatchStatus(Enum):
    AVAILABLE = "available"
    TESTING = "testing"
    APPROVED = "approved"
    DEPLOYED = "deployed"
    FAILED = "failed"
    NOT_AVAILABLE = "not_available"

@dataclass
class CVEInfo:
    cve_id: str
    cvss_score: float
    cvss_vector: str
    description: str
    published_date: datetime
    modified_date: datetime
    affected_products: List[str]
    references: List[str] = field(default_factory=list)

@dataclass
class PatchInfo:
    patch_id: str
    vulnerability_id: str
    patch_name: str
    patch_version: str
    patch_url: str
    patch_size: int
    requires_reboot: bool
    installation_time: int  # minutes
    dependencies: List[str] = field(default_factory=list)
    status: PatchStatus = PatchStatus.AVAILABLE
    tested_on: List[str] = field(default_factory=list)

@dataclass
class Vulnerability:
    vulnerability_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    status: VulnerabilityStatus
    discovered_at: datetime
    last_seen: datetime
    affected_assets: List[str]
    cve_info: Optional[CVEInfo] = None
    patch_info: Optional[PatchInfo] = None
    exploitability: str = "unknown"  # unknown, theoretical, poc, weaponized
    attack_vector: str = "unknown"  # local, network, physical
    remediation_steps: List[str] = field(default_factory=list)
    false_positive_reason: Optional[str] = None
    risk_score: float = 0.0

@dataclass
class AssetInfo:
    asset_id: str
    hostname: str
    ip_address: str
    os_type: str
    os_version: str
    software_inventory: List[Dict[str, str]]
    last_scanned: datetime
    criticality: str = "medium"  # low, medium, high, critical

class VulnerabilityScanner:
    """Advanced vulnerability scanning engine"""
    
    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.assets: Dict[str, AssetInfo] = {}
        self.patches: Dict[str, PatchInfo] = {}
        self.cve_database: Dict[str, CVEInfo] = {}
        self.scan_templates: Dict[str, Dict[str, Any]] = {}
        
        # Load vulnerability signatures
        self._load_vulnerability_signatures()
        self._load_cve_database()
    
    def _load_vulnerability_signatures(self):
        """Load vulnerability detection signatures"""
        self.vulnerability_signatures = {
            # Web vulnerabilities
            "sql_injection": {
                "patterns": [
                    r"SQL syntax.*error",
                    r"ORA-\d+",
                    r"MySQL.*error",
                    r"PostgreSQL.*error"
                ],
                "severity": VulnerabilitySeverity.HIGH,
                "description": "SQL Injection vulnerability detected"
            },
            "xss": {
                "patterns": [
                    r"<script[^>]*>.*</script>",
                    r"javascript:",
                    r"onerror\s*=",
                    r"onload\s*="
                ],
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Cross-Site Scripting (XSS) vulnerability"
            },
            "directory_traversal": {
                "patterns": [
                    r"\.\./",
                    r"\.\.\\",
                    r"%2e%2e%2f",
                    r"%2e%2e%5c"
                ],
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Directory traversal vulnerability"
            },
            # Network vulnerabilities
            "open_ports": {
                "high_risk_ports": [21, 23, 135, 139, 445, 1433, 3389],
                "medium_risk_ports": [22, 25, 53, 80, 110, 143, 993, 995],
                "severity": VulnerabilitySeverity.MEDIUM,
                "description": "Potentially risky open ports detected"
            },
            # System vulnerabilities
            "outdated_software": {
                "critical_software": ["windows", "linux", "apache", "nginx", "mysql", "postgresql"],
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Outdated software with known vulnerabilities"
            },
            "weak_passwords": {
                "patterns": [
                    r"^password$",
                    r"^123456$",
                    r"^admin$",
                    r"^root$"
                ],
                "severity": VulnerabilitySeverity.HIGH,
                "description": "Weak or default passwords detected"
            }
        }
    
    def _load_cve_database(self):
        """Load CVE database (simplified version)"""
        # In production, this would load from NIST NVD or similar
        sample_cves = [
            {
                "cve_id": "CVE-2023-23397",
                "cvss_score": 9.8,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                "description": "Critical vulnerability in Microsoft Outlook",
                "published_date": datetime(2023, 3, 14),
                "modified_date": datetime(2023, 3, 14),
                "affected_products": ["Microsoft Outlook"]
            },
            {
                "cve_id": "CVE-2023-0286",
                "cvss_score": 7.4,
                "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
                "description": "X.400 address type confusion in OpenSSL",
                "published_date": datetime(2023, 2, 7),
                "modified_date": datetime(2023, 2, 7),
                "affected_products": ["OpenSSL"]
            }
        ]
        
        for cve_data in sample_cves:
            cve_info = CVEInfo(**cve_data)
            self.cve_database[cve_info.cve_id] = cve_info
    
    async def scan_asset(self, asset_id: str, scan_type: str = "comprehensive") -> List[str]:
        """Scan a single asset for vulnerabilities"""
        try:
            if asset_id not in self.assets:
                raise ValueError(f"Asset {asset_id} not found")
            
            asset = self.assets[asset_id]
            detected_vulnerabilities = []
            
            logger.info(f"Starting {scan_type} vulnerability scan for {asset.hostname}")
            
            # Network vulnerability scan
            if scan_type in ["comprehensive", "network"]:
                network_vulns = await self._scan_network_vulnerabilities(asset)
                detected_vulnerabilities.extend(network_vulns)
            
            # Web application scan
            if scan_type in ["comprehensive", "web"]:
                web_vulns = await self._scan_web_vulnerabilities(asset)
                detected_vulnerabilities.extend(web_vulns)
            
            # System vulnerability scan
            if scan_type in ["comprehensive", "system"]:
                system_vulns = await self._scan_system_vulnerabilities(asset)
                detected_vulnerabilities.extend(system_vulns)
            
            # Update asset last scanned time
            asset.last_scanned = datetime.now()
            
            logger.info(f"Scan completed for {asset.hostname}: {len(detected_vulnerabilities)} vulnerabilities found")
            return detected_vulnerabilities
            
        except Exception as e:
            logger.error(f"Vulnerability scan failed for {asset_id}: {e}")
            raise
    
    async def _scan_network_vulnerabilities(self, asset: AssetInfo) -> List[str]:
        """Scan for network-based vulnerabilities"""
        vulnerabilities = []
        
        # Simulate network port scan
        await asyncio.sleep(2)  # Simulate scan time
        
        # Check for risky open ports (simulated)
        risky_ports = [22, 21, 23, 135, 445, 3389]  # Example detected ports
        
        if risky_ports:
            vuln_id = self._create_vulnerability(
                title="Risky Network Ports Open",
                description=f"Potentially risky ports detected: {', '.join(map(str, risky_ports))}",
                severity=VulnerabilitySeverity.MEDIUM,
                affected_assets=[asset.asset_id],
                attack_vector="network"
            )
            vulnerabilities.append(vuln_id)
        
        # Check for outdated network services
        if any("SSH" in software.get("name", "") for software in asset.software_inventory):
            vuln_id = self._create_vulnerability(
                title="Potentially Outdated SSH Service",
                description="SSH service may be running an outdated version",
                severity=VulnerabilitySeverity.LOW,
                affected_assets=[asset.asset_id],
                attack_vector="network"
            )
            vulnerabilities.append(vuln_id)
        
        return vulnerabilities
    
    async def _scan_web_vulnerabilities(self, asset: AssetInfo) -> List[str]:
        """Scan for web application vulnerabilities"""
        vulnerabilities = []
        
        # Simulate web vulnerability scan
        await asyncio.sleep(3)
        
        # Check if asset has web services
        has_web_service = any(
            "apache" in software.get("name", "").lower() or 
            "nginx" in software.get("name", "").lower() or
            "iis" in software.get("name", "").lower()
            for software in asset.software_inventory
        )
        
        if has_web_service:
            # Simulate common web vulnerabilities
            web_vulns = [
                {
                    "title": "Missing Security Headers",
                    "description": "Web server missing important security headers",
                    "severity": VulnerabilitySeverity.LOW
                },
                {
                    "title": "Outdated Web Server Version",
                    "description": "Web server may be running an outdated version",
                    "severity": VulnerabilitySeverity.MEDIUM
                }
            ]
            
            for vuln_data in web_vulns:
                vuln_id = self._create_vulnerability(
                    title=vuln_data["title"],
                    description=vuln_data["description"],
                    severity=vuln_data["severity"],
                    affected_assets=[asset.asset_id],
                    attack_vector="network"
                )
                vulnerabilities.append(vuln_id)
        
        return vulnerabilities
    
    async def _scan_system_vulnerabilities(self, asset: AssetInfo) -> List[str]:
        """Scan for system-level vulnerabilities"""
        vulnerabilities = []
        
        # Simulate system vulnerability scan
        await asyncio.sleep(4)
        
        # Check for outdated OS
        if "windows" in asset.os_type.lower():
            if "2019" in asset.os_version or "2016" in asset.os_version:
                vuln_id = self._create_vulnerability(
                    title="Outdated Windows Server",
                    description=f"Windows Server {asset.os_version} may have unpatched vulnerabilities",
                    severity=VulnerabilitySeverity.HIGH,
                    affected_assets=[asset.asset_id],
                    attack_vector="local",
                    cve_id="CVE-2023-23397"  # Example CVE
                )
                vulnerabilities.append(vuln_id)
        
        # Check for missing patches
        critical_software = ["mysql", "postgresql", "apache", "nginx"]
        for software in asset.software_inventory:
            software_name = software.get("name", "").lower()
            if any(critical in software_name for critical in critical_software):
                vuln_id = self._create_vulnerability(
                    title=f"Potentially Vulnerable {software.get('name')}",
                    description=f"{software.get('name')} version {software.get('version')} may have security vulnerabilities",
                    severity=VulnerabilitySeverity.MEDIUM,
                    affected_assets=[asset.asset_id],
                    attack_vector="network"
                )
                vulnerabilities.append(vuln_id)
        
        return vulnerabilities
    
    def _create_vulnerability(
        self,
        title: str,
        description: str,
        severity: VulnerabilitySeverity,
        affected_assets: List[str],
        attack_vector: str = "unknown",
        cve_id: Optional[str] = None
    ) -> str:
        """Create a new vulnerability record"""
        vuln_id = str(uuid4())
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(severity, affected_assets, attack_vector)
        
        vulnerability = Vulnerability(
            vulnerability_id=vuln_id,
            title=title,
            description=description,
            severity=severity,
            status=VulnerabilityStatus.OPEN,
            discovered_at=datetime.now(),
            last_seen=datetime.now(),
            affected_assets=affected_assets,
            attack_vector=attack_vector,
            risk_score=risk_score
        )
        
        # Add CVE information if available
        if cve_id and cve_id in self.cve_database:
            vulnerability.cve_info = self.cve_database[cve_id]
        
        # Check for available patches
        patch_info = self._find_available_patch(vulnerability)
        if patch_info:
            vulnerability.patch_info = patch_info
        
        self.vulnerabilities[vuln_id] = vulnerability
        
        logger.info(f"Created vulnerability: {title} ({vuln_id})")
        return vuln_id
    
    def _calculate_risk_score(
        self,
        severity: VulnerabilitySeverity,
        affected_assets: List[str],
        attack_vector: str
    ) -> float:
        """Calculate risk score for vulnerability"""
        # Base score by severity
        severity_scores = {
            VulnerabilitySeverity.INFO: 1.0,
            VulnerabilitySeverity.LOW: 3.0,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.CRITICAL: 9.0
        }
        
        base_score = severity_scores.get(severity, 5.0)
        
        # Adjust for number of affected assets
        asset_multiplier = min(1.0 + (len(affected_assets) * 0.1), 2.0)
        
        # Adjust for attack vector
        vector_multipliers = {
            "network": 1.5,
            "local": 1.0,
            "physical": 0.5,
            "unknown": 1.0
        }
        vector_multiplier = vector_multipliers.get(attack_vector, 1.0)
        
        # Calculate final risk score
        risk_score = base_score * asset_multiplier * vector_multiplier
        return min(risk_score, 10.0)  # Cap at 10.0
    
    def _find_available_patch(self, vulnerability: Vulnerability) -> Optional[PatchInfo]:
        """Find available patches for vulnerability"""
        # Simulate patch lookup
        if vulnerability.cve_info:
            # Create mock patch for CVE
            patch_id = f"PATCH-{vulnerability.cve_info.cve_id}"
            return PatchInfo(
                patch_id=patch_id,
                vulnerability_id=vulnerability.vulnerability_id,
                patch_name=f"Security Update for {vulnerability.cve_info.cve_id}",
                patch_version="1.0",
                patch_url=f"https://patches.example.com/{patch_id}",
                patch_size=25600,  # 25MB
                requires_reboot=True,
                installation_time=15
            )
        
        return None
    
    async def auto_patch_vulnerability(
        self,
        vulnerability_id: str,
        auto_approve: bool = False
    ) -> Dict[str, Any]:
        """Automatically patch a vulnerability"""
        try:
            if vulnerability_id not in self.vulnerabilities:
                raise ValueError(f"Vulnerability {vulnerability_id} not found")
            
            vulnerability = self.vulnerabilities[vulnerability_id]
            
            if not vulnerability.patch_info:
                return {
                    "success": False,
                    "message": "No patch available for this vulnerability"
                }
            
            patch = vulnerability.patch_info
            
            # Check if auto-approval is enabled or patch is pre-approved
            if not auto_approve and patch.status != PatchStatus.APPROVED:
                return {
                    "success": False,
                    "message": "Patch requires manual approval",
                    "patch_id": patch.patch_id
                }
            
            # Start patching process
            vulnerability.status = VulnerabilityStatus.PATCHING
            patch.status = PatchStatus.DEPLOYED
            
            logger.info(f"Starting auto-patch for vulnerability {vulnerability_id}")
            
            # Simulate patch deployment
            for asset_id in vulnerability.affected_assets:
                await self._deploy_patch_to_asset(asset_id, patch)
            
            # Update vulnerability status
            vulnerability.status = VulnerabilityStatus.PATCHED
            
            return {
                "success": True,
                "message": f"Patch {patch.patch_id} deployed successfully",
                "affected_assets": vulnerability.affected_assets,
                "requires_reboot": patch.requires_reboot
            }
            
        except Exception as e:
            logger.error(f"Auto-patch failed for {vulnerability_id}: {e}")
            return {
                "success": False,
                "message": f"Patch deployment failed: {str(e)}"
            }
    
    async def _deploy_patch_to_asset(self, asset_id: str, patch: PatchInfo):
        """Deploy patch to specific asset"""
        logger.info(f"Deploying patch {patch.patch_id} to asset {asset_id}")
        
        # Simulate patch deployment time
        await asyncio.sleep(patch.installation_time / 10)  # Scale down for demo
        
        # Simulate success/failure
        import random
        if random.random() > 0.1:  # 90% success rate
            logger.info(f"Patch {patch.patch_id} deployed successfully to {asset_id}")
        else:
            logger.warning(f"Patch {patch.patch_id} deployment failed on {asset_id}")
            raise Exception(f"Patch deployment failed on {asset_id}")
    
    def add_asset(
        self,
        hostname: str,
        ip_address: str,
        os_type: str,
        os_version: str,
        software_inventory: List[Dict[str, str]],
        criticality: str = "medium"
    ) -> str:
        """Add asset to vulnerability management"""
        asset_id = str(uuid4())
        
        asset = AssetInfo(
            asset_id=asset_id,
            hostname=hostname,
            ip_address=ip_address,
            os_type=os_type,
            os_version=os_version,
            software_inventory=software_inventory,
            last_scanned=datetime.now(),
            criticality=criticality
        )
        
        self.assets[asset_id] = asset
        logger.info(f"Added asset: {hostname} ({asset_id})")
        
        return asset_id
    
    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """Get vulnerability management summary"""
        total_vulns = len(self.vulnerabilities)
        
        if total_vulns == 0:
            return {
                "total_vulnerabilities": 0,
                "by_severity": {},
                "by_status": {},
                "critical_assets": 0,
                "patch_available": 0
            }
        
        # Count by severity and status
        by_severity = {}
        by_status = {}
        patch_available = 0
        
        for vuln in self.vulnerabilities.values():
            severity = vuln.severity.value
            status = vuln.status.value
            
            by_severity[severity] = by_severity.get(severity, 0) + 1
            by_status[status] = by_status.get(status, 0) + 1
            
            if vuln.patch_info:
                patch_available += 1
        
        # Count critical assets
        critical_assets = len([
            asset for asset in self.assets.values()
            if asset.criticality == "critical"
        ])
        
        return {
            "total_vulnerabilities": total_vulns,
            "by_severity": by_severity,
            "by_status": by_status,
            "critical_assets": critical_assets,
            "patch_available": patch_available,
            "total_assets": len(self.assets)
        }

# Global vulnerability scanner instance
vulnerability_scanner = VulnerabilityScanner()

# Initialize sample assets
async def initialize_sample_assets():
    """Initialize sample assets for demonstration"""
    
    sample_assets = [
        {
            "hostname": "web-server-01",
            "ip_address": "192.168.1.10",
            "os_type": "Linux",
            "os_version": "Ubuntu 20.04",
            "software_inventory": [
                {"name": "Apache", "version": "2.4.41"},
                {"name": "MySQL", "version": "8.0.25"},
                {"name": "PHP", "version": "7.4.3"}
            ],
            "criticality": "high"
        },
        {
            "hostname": "database-01",
            "ip_address": "192.168.1.20",
            "os_type": "Windows",
            "os_version": "Windows Server 2019",
            "software_inventory": [
                {"name": "Microsoft SQL Server", "version": "2019"},
                {"name": "IIS", "version": "10.0"}
            ],
            "criticality": "critical"
        },
        {
            "hostname": "workstation-05",
            "ip_address": "192.168.1.105",
            "os_type": "Windows",
            "os_version": "Windows 10",
            "software_inventory": [
                {"name": "Microsoft Office", "version": "2019"},
                {"name": "Google Chrome", "version": "120.0"}
            ],
            "criticality": "medium"
        }
    ]
    
    for asset_data in sample_assets:
        vulnerability_scanner.add_asset(**asset_data)