"""
Vulnerability Management API Endpoints
Real-time vulnerability scanning and patch management
"""

import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from pydantic import BaseModel

from app.db.database import get_db
from app.services.vulnerability_management import vulnerability_scanner

logger = logging.getLogger(__name__)
router = APIRouter()

class AssetCreateRequest(BaseModel):
    hostname: str
    ip_address: str
    os_type: str
    os_version: str
    software_inventory: List[Dict[str, str]]
    criticality: str = "medium"

class VulnerabilityScanRequest(BaseModel):
    asset_id: str
    scan_type: str = "comprehensive"  # comprehensive, network, web, system

class PatchDeployRequest(BaseModel):
    vulnerability_id: str
    auto_approve: bool = False

class VulnerabilityResponse(BaseModel):
    vulnerability_id: str
    title: str
    description: str
    severity: str
    status: str
    discovered_at: str
    affected_assets: List[str]
    risk_score: float
    has_patch: bool
    cve_id: Optional[str] = None

@router.post("/assets", response_model=Dict[str, str])
async def create_asset(
    request: AssetCreateRequest,
    db: Session = Depends(get_db)
):
    """Add new asset for vulnerability management"""
    try:
        asset_id = vulnerability_scanner.add_asset(
            hostname=request.hostname,
            ip_address=request.ip_address,
            os_type=request.os_type,
            os_version=request.os_version,
            software_inventory=request.software_inventory,
            criticality=request.criticality
        )
        
        return {"asset_id": asset_id, "status": "created"}
        
    except Exception as e:
        logger.error(f"Create asset error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/assets")
async def get_assets(
    limit: int = 50,
    criticality: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Get all managed assets"""
    try:
        assets = []
        
        for asset in vulnerability_scanner.assets.values():
            # Apply criticality filter
            if criticality and asset.criticality != criticality:
                continue
            
            # Count vulnerabilities for this asset
            asset_vulns = [
                v for v in vulnerability_scanner.vulnerabilities.values()
                if asset.asset_id in v.affected_assets
            ]
            
            assets.append({
                "asset_id": asset.asset_id,
                "hostname": asset.hostname,
                "ip_address": asset.ip_address,
                "os_type": asset.os_type,
                "os_version": asset.os_version,
                "criticality": asset.criticality,
                "last_scanned": asset.last_scanned.isoformat(),
                "software_count": len(asset.software_inventory),
                "vulnerability_count": len(asset_vulns),
                "critical_vulns": len([v for v in asset_vulns if v.severity.value == "critical"]),
                "high_vulns": len([v for v in asset_vulns if v.severity.value == "high"])
            })
        
        # Sort by criticality and vulnerability count
        criticality_order = {"critical": 4, "high": 3, "medium": 2, "low": 1}
        assets.sort(key=lambda x: (criticality_order.get(x["criticality"], 0), x["vulnerability_count"]), reverse=True)
        
        return {"assets": assets[:limit], "total": len(assets)}
        
    except Exception as e:
        logger.error(f"Get assets error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/assets/{asset_id}")
async def get_asset_details(
    asset_id: str,
    db: Session = Depends(get_db)
):
    """Get detailed asset information"""
    try:
        if asset_id not in vulnerability_scanner.assets:
            raise HTTPException(status_code=404, detail="Asset not found")
        
        asset = vulnerability_scanner.assets[asset_id]
        
        # Get vulnerabilities for this asset
        asset_vulnerabilities = [
            {
                "vulnerability_id": v.vulnerability_id,
                "title": v.title,
                "severity": v.severity.value,
                "status": v.status.value,
                "risk_score": v.risk_score,
                "has_patch": v.patch_info is not None,
                "discovered_at": v.discovered_at.isoformat()
            }
            for v in vulnerability_scanner.vulnerabilities.values()
            if asset_id in v.affected_assets
        ]
        
        return {
            "asset_id": asset.asset_id,
            "hostname": asset.hostname,
            "ip_address": asset.ip_address,
            "os_type": asset.os_type,
            "os_version": asset.os_version,
            "criticality": asset.criticality,
            "last_scanned": asset.last_scanned.isoformat(),
            "software_inventory": asset.software_inventory,
            "vulnerabilities": asset_vulnerabilities,
            "vulnerability_summary": {
                "total": len(asset_vulnerabilities),
                "critical": len([v for v in asset_vulnerabilities if v["severity"] == "critical"]),
                "high": len([v for v in asset_vulnerabilities if v["severity"] == "high"]),
                "medium": len([v for v in asset_vulnerabilities if v["severity"] == "medium"]),
                "low": len([v for v in asset_vulnerabilities if v["severity"] == "low"])
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Get asset details error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/scan", response_model=Dict[str, Any])
async def scan_asset(
    request: VulnerabilityScanRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """Scan asset for vulnerabilities"""
    try:
        if request.asset_id not in vulnerability_scanner.assets:
            raise HTTPException(status_code=404, detail="Asset not found")
        
        # Run scan in background
        background_tasks.add_task(
            run_vulnerability_scan,
            request.asset_id,
            request.scan_type
        )
        
        return {
            "success": True,
            "message": f"Vulnerability scan started for asset {request.asset_id}",
            "scan_type": request.scan_type,
            "estimated_time": "5-10 minutes"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Scan asset error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/vulnerabilities")
async def get_vulnerabilities(
    limit: int = 100,
    severity: Optional[str] = None,
    status: Optional[str] = None,
    asset_id: Optional[str] = None,
    has_patch: Optional[bool] = None,
    db: Session = Depends(get_db)
):
    """Get vulnerabilities with filtering"""
    try:
        vulnerabilities = []
        
        for vuln in vulnerability_scanner.vulnerabilities.values():
            # Apply filters
            if severity and vuln.severity.value != severity:
                continue
            if status and vuln.status.value != status:
                continue
            if asset_id and asset_id not in vuln.affected_assets:
                continue
            if has_patch is not None and (vuln.patch_info is not None) != has_patch:
                continue
            
            # Get CVE ID if available
            cve_id = vuln.cve_info.cve_id if vuln.cve_info else None
            
            vulnerabilities.append({
                "vulnerability_id": vuln.vulnerability_id,
                "title": vuln.title,
                "description": vuln.description,
                "severity": vuln.severity.value,
                "status": vuln.status.value,
                "discovered_at": vuln.discovered_at.isoformat(),
                "last_seen": vuln.last_seen.isoformat(),
                "affected_assets": vuln.affected_assets,
                "risk_score": vuln.risk_score,
                "attack_vector": vuln.attack_vector,
                "exploitability": vuln.exploitability,
                "has_patch": vuln.patch_info is not None,
                "cve_id": cve_id,
                "cvss_score": vuln.cve_info.cvss_score if vuln.cve_info else None
            })
        
        # Sort by risk score and discovery date
        vulnerabilities.sort(key=lambda x: (x["risk_score"], x["discovered_at"]), reverse=True)
        
        return {"vulnerabilities": vulnerabilities[:limit], "total": len(vulnerabilities)}
        
    except Exception as e:
        logger.error(f"Get vulnerabilities error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/vulnerabilities/{vulnerability_id}")
async def get_vulnerability_details(
    vulnerability_id: str,
    db: Session = Depends(get_db)
):
    """Get detailed vulnerability information"""
    try:
        if vulnerability_id not in vulnerability_scanner.vulnerabilities:
            raise HTTPException(status_code=404, detail="Vulnerability not found")
        
        vuln = vulnerability_scanner.vulnerabilities[vulnerability_id]
        
        # Build response
        response = {
            "vulnerability_id": vuln.vulnerability_id,
            "title": vuln.title,
            "description": vuln.description,
            "severity": vuln.severity.value,
            "status": vuln.status.value,
            "discovered_at": vuln.discovered_at.isoformat(),
            "last_seen": vuln.last_seen.isoformat(),
            "affected_assets": vuln.affected_assets,
            "risk_score": vuln.risk_score,
            "attack_vector": vuln.attack_vector,
            "exploitability": vuln.exploitability,
            "remediation_steps": vuln.remediation_steps,
            "false_positive_reason": vuln.false_positive_reason
        }
        
        # Add CVE information if available
        if vuln.cve_info:
            response["cve_info"] = {
                "cve_id": vuln.cve_info.cve_id,
                "cvss_score": vuln.cve_info.cvss_score,
                "cvss_vector": vuln.cve_info.cvss_vector,
                "description": vuln.cve_info.description,
                "published_date": vuln.cve_info.published_date.isoformat(),
                "affected_products": vuln.cve_info.affected_products,
                "references": vuln.cve_info.references
            }
        
        # Add patch information if available
        if vuln.patch_info:
            response["patch_info"] = {
                "patch_id": vuln.patch_info.patch_id,
                "patch_name": vuln.patch_info.patch_name,
                "patch_version": vuln.patch_info.patch_version,
                "patch_size": vuln.patch_info.patch_size,
                "requires_reboot": vuln.patch_info.requires_reboot,
                "installation_time": vuln.patch_info.installation_time,
                "status": vuln.patch_info.status.value,
                "dependencies": vuln.patch_info.dependencies
            }
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Get vulnerability details error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/patch", response_model=Dict[str, Any])
async def deploy_patch(
    request: PatchDeployRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """Deploy patch for vulnerability"""
    try:
        if request.vulnerability_id not in vulnerability_scanner.vulnerabilities:
            raise HTTPException(status_code=404, detail="Vulnerability not found")
        
        # Start patch deployment in background
        background_tasks.add_task(
            run_patch_deployment,
            request.vulnerability_id,
            request.auto_approve
        )
        
        return {
            "success": True,
            "message": f"Patch deployment started for vulnerability {request.vulnerability_id}",
            "auto_approve": request.auto_approve
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Deploy patch error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/summary")
async def get_vulnerability_summary(db: Session = Depends(get_db)):
    """Get vulnerability management summary"""
    try:
        summary = vulnerability_scanner.get_vulnerability_summary()
        
        # Add additional metrics
        recent_scans = []
        for asset in vulnerability_scanner.assets.values():
            if asset.last_scanned > datetime.now() - timedelta(hours=24):
                recent_scans.append(asset.asset_id)
        
        # Calculate patch deployment rate
        patchable_vulns = [
            v for v in vulnerability_scanner.vulnerabilities.values()
            if v.patch_info is not None
        ]
        patched_vulns = [
            v for v in patchable_vulns
            if v.status.value == "patched"
        ]
        patch_deployment_rate = len(patched_vulns) / len(patchable_vulns) if patchable_vulns else 0
        
        summary.update({
            "recent_scans_24h": len(recent_scans),
            "patch_deployment_rate": round(patch_deployment_rate, 2),
            "high_risk_assets": len([
                asset for asset in vulnerability_scanner.assets.values()
                if asset.criticality in ["high", "critical"]
            ])
        })
        
        return summary
        
    except Exception as e:
        logger.error(f"Get vulnerability summary error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/simulate")
async def simulate_vulnerability_scan(
    asset_type: str = "web_server",
    vulnerability_count: int = 5,
    db: Session = Depends(get_db)
):
    """Simulate vulnerability scan for testing"""
    try:
        # Create sample asset if needed
        asset_templates = {
            "web_server": {
                "hostname": "test-web-server",
                "ip_address": "192.168.1.200",
                "os_type": "Linux",
                "os_version": "Ubuntu 22.04",
                "software_inventory": [
                    {"name": "Apache", "version": "2.4.52"},
                    {"name": "MySQL", "version": "8.0.30"},
                    {"name": "PHP", "version": "8.1.2"}
                ],
                "criticality": "high"
            },
            "database_server": {
                "hostname": "test-db-server",
                "ip_address": "192.168.1.201",
                "os_type": "Windows",
                "os_version": "Windows Server 2022",
                "software_inventory": [
                    {"name": "Microsoft SQL Server", "version": "2022"},
                    {"name": "IIS", "version": "10.0"}
                ],
                "criticality": "critical"
            },
            "workstation": {
                "hostname": "test-workstation",
                "ip_address": "192.168.1.202",
                "os_type": "Windows",
                "os_version": "Windows 11",
                "software_inventory": [
                    {"name": "Microsoft Office", "version": "2021"},
                    {"name": "Adobe Acrobat", "version": "2023.001"}
                ],
                "criticality": "medium"
            }
        }
        
        if asset_type not in asset_templates:
            raise HTTPException(
                status_code=400,
                detail=f"Unknown asset type. Available: {list(asset_templates.keys())}"
            )
        
        # Create test asset
        asset_data = asset_templates[asset_type]
        asset_id = vulnerability_scanner.add_asset(**asset_data)
        
        # Run vulnerability scan
        detected_vulnerabilities = await vulnerability_scanner.scan_asset(asset_id, "comprehensive")
        
        return {
            "success": True,
            "message": f"Simulated vulnerability scan for {asset_type}",
            "asset_id": asset_id,
            "hostname": asset_data["hostname"],
            "vulnerabilities_found": len(detected_vulnerabilities),
            "vulnerability_ids": detected_vulnerabilities
        }
        
    except Exception as e:
        logger.error(f"Simulate vulnerability scan error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/metrics")
async def get_vulnerability_metrics(
    days: int = 30,
    db: Session = Depends(get_db)
):
    """Get vulnerability management metrics"""
    try:
        cutoff = datetime.now() - timedelta(days=days)
        
        # Get vulnerabilities discovered in time window
        recent_vulns = [
            v for v in vulnerability_scanner.vulnerabilities.values()
            if v.discovered_at > cutoff
        ]
        
        # Calculate metrics
        total_vulns = len(recent_vulns)
        
        severity_distribution = {}
        status_distribution = {}
        
        for vuln in recent_vulns:
            severity = vuln.severity.value
            status = vuln.status.value
            
            severity_distribution[severity] = severity_distribution.get(severity, 0) + 1
            status_distribution[status] = status_distribution.get(status, 0) + 1
        
        # Calculate resolution rates
        resolved_vulns = status_distribution.get("patched", 0) + status_distribution.get("mitigated", 0)
        resolution_rate = resolved_vulns / total_vulns if total_vulns > 0 else 0
        
        # Asset coverage metrics
        total_assets = len(vulnerability_scanner.assets)
        scanned_assets = len([
            asset for asset in vulnerability_scanner.assets.values()
            if asset.last_scanned > cutoff
        ])
        scan_coverage = scanned_assets / total_assets if total_assets > 0 else 0
        
        # Risk metrics
        high_risk_vulns = len([v for v in recent_vulns if v.risk_score >= 7.0])
        avg_risk_score = sum(v.risk_score for v in recent_vulns) / len(recent_vulns) if recent_vulns else 0
        
        return {
            "time_window_days": days,
            "vulnerability_metrics": {
                "total_discovered": total_vulns,
                "severity_distribution": severity_distribution,
                "status_distribution": status_distribution,
                "resolution_rate": round(resolution_rate, 2),
                "high_risk_count": high_risk_vulns,
                "avg_risk_score": round(avg_risk_score, 2)
            },
            "asset_metrics": {
                "total_assets": total_assets,
                "scanned_assets": scanned_assets,
                "scan_coverage": round(scan_coverage, 2)
            },
            "patch_metrics": {
                "patches_available": len([v for v in recent_vulns if v.patch_info]),
                "patches_deployed": status_distribution.get("patched", 0),
                "auto_patch_rate": "85%"  # Simulated metric
            }
        }
        
    except Exception as e:
        logger.error(f"Get vulnerability metrics error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/health")
async def health_check():
    """Health check for vulnerability management"""
    return {
        "status": "healthy",
        "service": "vulnerability_management",
        "assets_managed": len(vulnerability_scanner.assets),
        "vulnerabilities_tracked": len(vulnerability_scanner.vulnerabilities),
        "patches_available": len([
            v for v in vulnerability_scanner.vulnerabilities.values()
            if v.patch_info is not None
        ])
    }

# Background tasks
async def run_vulnerability_scan(asset_id: str, scan_type: str):
    """Background task to run vulnerability scan"""
    try:
        vulnerabilities = await vulnerability_scanner.scan_asset(asset_id, scan_type)
        logger.info(f"Vulnerability scan completed for {asset_id}: {len(vulnerabilities)} vulnerabilities found")
    except Exception as e:
        logger.error(f"Background vulnerability scan failed: {e}")

async def run_patch_deployment(vulnerability_id: str, auto_approve: bool):
    """Background task to deploy patch"""
    try:
        result = await vulnerability_scanner.auto_patch_vulnerability(vulnerability_id, auto_approve)
        if result["success"]:
            logger.info(f"Patch deployment completed for vulnerability {vulnerability_id}")
        else:
            logger.warning(f"Patch deployment failed for vulnerability {vulnerability_id}: {result['message']}")
    except Exception as e:
        logger.error(f"Background patch deployment failed: {e}")